{"ast":null,"code":"export function getQuickSortAnimations(array) {\n  const animations = [];\n  doQuick(array, 0, array.length - 1, animations);\n  return animations;\n}\n\nfunction doQuick(array, start, end, animations) {\n  if (start >= end) {\n    return;\n  }\n\n  let pivot = start,\n      i = start + 1,\n      right = end;\n\n  while (right >= i) {\n    if (array[right] < array[pivot] && array[i] > array[pivot]) {\n      let temp = array[right];\n      array[right] = array[i];\n      array[i] = temp;\n      animations.push([3, i, array[i], right, array[right]]);\n    }\n\n    if (array[right] >= array[pivot]) {\n      right--;\n    }\n\n    if (array[i] <= array[pivot]) {\n      i++;\n    }\n\n    if (right >= i) {}\n  }\n\n  if (pivot !== right) {\n    let temp = array[right];\n    array[right] = array[pivot];\n    array[pivot] = temp;\n    animations.push([3, pivot, array[pivot], right, array[right]]);\n  }\n\n  doQuick(array, start, right - 1, animations);\n  doQuick(array, right + 1, end, animations);\n} // function doQuick(array, low, high, animations) {\n//   if (low < high) {\n//     // partIndex is partitioning index, array[p]\n//     // is now at right place\n//     let partIndex = partition(array, low, high, animations);\n//     // Separately sort elements before\n//     // partition and after partition\n//     doQuick(array, low, partIndex - 1, animations);\n//     doQuick(array, partIndex + 1, high, animations);\n//   }\n// }\n// function partition(array, low, high, animations) {\n//   // pivot\n//   let pivot = array[high];\n//   // Index of smaller element and\n//   // indicates the right position\n//   // of pivot found so far\n//   let i = low - 1;\n//   for (let j = low; j <= high - 1; j++) {\n//     // If current element is smaller\n//     // than the pivot\n//     animations.push([1, i, j], [2, i, j]);\n//     animations.push([3, j, array[j], i, array[i]]);\n//     if (array[j] < pivot) {\n//       // Increment index of\n//       // smaller element\n//       i++;\n//       let temp = array[i];\n//       array[i] = array[j];\n//       array[j] = temp;\n//       animations.push([4, high]); //, [5, high]);\n//     }\n//   }\n//   let temp = array[i + 1];\n//   array[i + 1] = array[high];\n//   array[high] = temp;\n//   animations.push([1, i + 1, high], [2, i + 1, high]);\n//   animations.push([3, high, array[high], i + 1, array[i + 1]]);\n//   return i + 1;\n// }","map":{"version":3,"sources":["/home/matta/algo_viz/src/Algos/QuickSort.js"],"names":["getQuickSortAnimations","array","animations","doQuick","length","start","end","pivot","i","right","temp","push"],"mappings":"AAAA,OAAO,SAASA,sBAAT,CAAgCC,KAAhC,EAAuC;AAC5C,QAAMC,UAAU,GAAG,EAAnB;AACAC,EAAAA,OAAO,CAACF,KAAD,EAAQ,CAAR,EAAWA,KAAK,CAACG,MAAN,GAAe,CAA1B,EAA6BF,UAA7B,CAAP;AACA,SAAOA,UAAP;AACD;;AAED,SAASC,OAAT,CAAiBF,KAAjB,EAAwBI,KAAxB,EAA+BC,GAA/B,EAAoCJ,UAApC,EAAgD;AAC9C,MAAIG,KAAK,IAAIC,GAAb,EAAkB;AAChB;AACD;;AACD,MAAIC,KAAK,GAAGF,KAAZ;AAAA,MACEG,CAAC,GAAGH,KAAK,GAAG,CADd;AAAA,MAEEI,KAAK,GAAGH,GAFV;;AAIA,SAAOG,KAAK,IAAID,CAAhB,EAAmB;AACjB,QAAIP,KAAK,CAACQ,KAAD,CAAL,GAAeR,KAAK,CAACM,KAAD,CAApB,IAA+BN,KAAK,CAACO,CAAD,CAAL,GAAWP,KAAK,CAACM,KAAD,CAAnD,EAA4D;AAC1D,UAAIG,IAAI,GAAGT,KAAK,CAACQ,KAAD,CAAhB;AACAR,MAAAA,KAAK,CAACQ,KAAD,CAAL,GAAeR,KAAK,CAACO,CAAD,CAApB;AACAP,MAAAA,KAAK,CAACO,CAAD,CAAL,GAAWE,IAAX;AACAR,MAAAA,UAAU,CAACS,IAAX,CAAgB,CAAC,CAAD,EAAIH,CAAJ,EAAOP,KAAK,CAACO,CAAD,CAAZ,EAAiBC,KAAjB,EAAwBR,KAAK,CAACQ,KAAD,CAA7B,CAAhB;AACD;;AACD,QAAIR,KAAK,CAACQ,KAAD,CAAL,IAAgBR,KAAK,CAACM,KAAD,CAAzB,EAAkC;AAChCE,MAAAA,KAAK;AACN;;AACD,QAAIR,KAAK,CAACO,CAAD,CAAL,IAAYP,KAAK,CAACM,KAAD,CAArB,EAA8B;AAC5BC,MAAAA,CAAC;AACF;;AACD,QAAIC,KAAK,IAAID,CAAb,EAAgB,CACf;AACF;;AACD,MAAID,KAAK,KAAKE,KAAd,EAAqB;AACnB,QAAIC,IAAI,GAAGT,KAAK,CAACQ,KAAD,CAAhB;AACAR,IAAAA,KAAK,CAACQ,KAAD,CAAL,GAAeR,KAAK,CAACM,KAAD,CAApB;AACAN,IAAAA,KAAK,CAACM,KAAD,CAAL,GAAeG,IAAf;AACAR,IAAAA,UAAU,CAACS,IAAX,CAAgB,CAAC,CAAD,EAAIJ,KAAJ,EAAWN,KAAK,CAACM,KAAD,CAAhB,EAAyBE,KAAzB,EAAgCR,KAAK,CAACQ,KAAD,CAArC,CAAhB;AACD;;AACDN,EAAAA,OAAO,CAACF,KAAD,EAAQI,KAAR,EAAeI,KAAK,GAAG,CAAvB,EAA0BP,UAA1B,CAAP;AACAC,EAAAA,OAAO,CAACF,KAAD,EAAQQ,KAAK,GAAG,CAAhB,EAAmBH,GAAnB,EAAwBJ,UAAxB,CAAP;AACD,C,CAED;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA","sourcesContent":["export function getQuickSortAnimations(array) {\n  const animations = [];\n  doQuick(array, 0, array.length - 1, animations);\n  return animations;\n}\n\nfunction doQuick(array, start, end, animations) {\n  if (start >= end) {\n    return;\n  }\n  let pivot = start,\n    i = start + 1,\n    right = end;\n\n  while (right >= i) {\n    if (array[right] < array[pivot] && array[i] > array[pivot]) {\n      let temp = array[right];\n      array[right] = array[i];\n      array[i] = temp;\n      animations.push([3, i, array[i], right, array[right]]);\n    }\n    if (array[right] >= array[pivot]) {\n      right--;\n    }\n    if (array[i] <= array[pivot]) {\n      i++;\n    }\n    if (right >= i) {\n    }\n  }\n  if (pivot !== right) {\n    let temp = array[right];\n    array[right] = array[pivot];\n    array[pivot] = temp;\n    animations.push([3, pivot, array[pivot], right, array[right]]);\n  }\n  doQuick(array, start, right - 1, animations);\n  doQuick(array, right + 1, end, animations);\n}\n\n// function doQuick(array, low, high, animations) {\n//   if (low < high) {\n//     // partIndex is partitioning index, array[p]\n//     // is now at right place\n//     let partIndex = partition(array, low, high, animations);\n\n//     // Separately sort elements before\n//     // partition and after partition\n//     doQuick(array, low, partIndex - 1, animations);\n//     doQuick(array, partIndex + 1, high, animations);\n//   }\n// }\n\n// function partition(array, low, high, animations) {\n//   // pivot\n\n//   let pivot = array[high];\n//   // Index of smaller element and\n//   // indicates the right position\n//   // of pivot found so far\n//   let i = low - 1;\n\n//   for (let j = low; j <= high - 1; j++) {\n//     // If current element is smaller\n//     // than the pivot\n//     animations.push([1, i, j], [2, i, j]);\n//     animations.push([3, j, array[j], i, array[i]]);\n//     if (array[j] < pivot) {\n//       // Increment index of\n//       // smaller element\n\n//       i++;\n\n//       let temp = array[i];\n//       array[i] = array[j];\n//       array[j] = temp;\n//       animations.push([4, high]); //, [5, high]);\n//     }\n//   }\n//   let temp = array[i + 1];\n//   array[i + 1] = array[high];\n//   array[high] = temp;\n//   animations.push([1, i + 1, high], [2, i + 1, high]);\n//   animations.push([3, high, array[high], i + 1, array[i + 1]]);\n\n//   return i + 1;\n// }\n"]},"metadata":{},"sourceType":"module"}