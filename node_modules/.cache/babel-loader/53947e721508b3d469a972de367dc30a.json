{"ast":null,"code":"export function getHeapSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  doHeap(array, animations);\n  return animations;\n}\n\nfunction doHeap(array) {\n  var n = arr.length; // Build heap (rearrange array)\n\n  for (var i = Math.floor(n / 2) - 1; i >= 0; i--) heapify(arr, n, i); // One by one extract an element from heap\n\n\n  for (var i = n - 1; i > 0; i--) {\n    // Move current root to end\n    var temp = arr[0];\n    arr[0] = arr[i];\n    arr[i] = temp; // call max heapify on the reduced heap\n\n    heapify(arr, i, 0);\n  }\n} // To heapify a subtree rooted with node i which is\n// an index in arr[]. n is size of heap\n\n\nfunction heapify(arr, n, i) {\n  var largest = i; // Initialize largest as root\n\n  var l = 2 * i + 1; // left = 2*i + 1\n\n  var r = 2 * i + 2; // right = 2*i + 2\n  // If left child is larger than root\n\n  if (l < n && arr[l] > arr[largest]) largest = l; // If right child is larger than largest so far\n\n  if (r < n && arr[r] > arr[largest]) largest = r; // If largest is not root\n\n  if (largest != i) {\n    var swap = arr[i];\n    arr[i] = arr[largest];\n    arr[largest] = swap; // Recursively heapify the affected sub-tree\n\n    heapify(arr, n, largest);\n  }\n}","map":{"version":3,"sources":["/home/matta/algo_viz/src/Algos/HeapSort.js"],"names":["getHeapSortAnimations","array","animations","length","doHeap","n","arr","i","Math","floor","heapify","temp","largest","l","r","swap"],"mappings":"AAAA,OAAO,SAASA,qBAAT,CAA+BC,KAA/B,EAAsC;AAC3C,QAAMC,UAAU,GAAG,EAAnB;AACA,MAAID,KAAK,CAACE,MAAN,IAAgB,CAApB,EAAuB,OAAOF,KAAP;AACvBG,EAAAA,MAAM,CAACH,KAAD,EAAQC,UAAR,CAAN;AACA,SAAOA,UAAP;AACD;;AAED,SAASE,MAAT,CAAgBH,KAAhB,EAAuB;AACrB,MAAII,CAAC,GAAGC,GAAG,CAACH,MAAZ,CADqB,CAGrB;;AACA,OAAK,IAAII,CAAC,GAAGC,IAAI,CAACC,KAAL,CAAWJ,CAAC,GAAG,CAAf,IAAoB,CAAjC,EAAoCE,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiDG,OAAO,CAACJ,GAAD,EAAMD,CAAN,EAASE,CAAT,CAAP,CAJ5B,CAMrB;;;AACA,OAAK,IAAIA,CAAC,GAAGF,CAAC,GAAG,CAAjB,EAAoBE,CAAC,GAAG,CAAxB,EAA2BA,CAAC,EAA5B,EAAgC;AAC9B;AACA,QAAII,IAAI,GAAGL,GAAG,CAAC,CAAD,CAAd;AACAA,IAAAA,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAACC,CAAD,CAAZ;AACAD,IAAAA,GAAG,CAACC,CAAD,CAAH,GAASI,IAAT,CAJ8B,CAM9B;;AACAD,IAAAA,OAAO,CAACJ,GAAD,EAAMC,CAAN,EAAS,CAAT,CAAP;AACD;AACF,C,CAED;AACA;;;AACA,SAASG,OAAT,CAAiBJ,GAAjB,EAAsBD,CAAtB,EAAyBE,CAAzB,EAA4B;AAC1B,MAAIK,OAAO,GAAGL,CAAd,CAD0B,CACT;;AACjB,MAAIM,CAAC,GAAG,IAAIN,CAAJ,GAAQ,CAAhB,CAF0B,CAEP;;AACnB,MAAIO,CAAC,GAAG,IAAIP,CAAJ,GAAQ,CAAhB,CAH0B,CAGP;AAEnB;;AACA,MAAIM,CAAC,GAAGR,CAAJ,IAASC,GAAG,CAACO,CAAD,CAAH,GAASP,GAAG,CAACM,OAAD,CAAzB,EAAoCA,OAAO,GAAGC,CAAV,CANV,CAQ1B;;AACA,MAAIC,CAAC,GAAGT,CAAJ,IAASC,GAAG,CAACQ,CAAD,CAAH,GAASR,GAAG,CAACM,OAAD,CAAzB,EAAoCA,OAAO,GAAGE,CAAV,CATV,CAW1B;;AACA,MAAIF,OAAO,IAAIL,CAAf,EAAkB;AAChB,QAAIQ,IAAI,GAAGT,GAAG,CAACC,CAAD,CAAd;AACAD,IAAAA,GAAG,CAACC,CAAD,CAAH,GAASD,GAAG,CAACM,OAAD,CAAZ;AACAN,IAAAA,GAAG,CAACM,OAAD,CAAH,GAAeG,IAAf,CAHgB,CAKhB;;AACAL,IAAAA,OAAO,CAACJ,GAAD,EAAMD,CAAN,EAASO,OAAT,CAAP;AACD;AACF","sourcesContent":["export function getHeapSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  doHeap(array, animations);\n  return animations;\n}\n\nfunction doHeap(array) {\n  var n = arr.length;\n\n  // Build heap (rearrange array)\n  for (var i = Math.floor(n / 2) - 1; i >= 0; i--) heapify(arr, n, i);\n\n  // One by one extract an element from heap\n  for (var i = n - 1; i > 0; i--) {\n    // Move current root to end\n    var temp = arr[0];\n    arr[0] = arr[i];\n    arr[i] = temp;\n\n    // call max heapify on the reduced heap\n    heapify(arr, i, 0);\n  }\n}\n\n// To heapify a subtree rooted with node i which is\n// an index in arr[]. n is size of heap\nfunction heapify(arr, n, i) {\n  var largest = i; // Initialize largest as root\n  var l = 2 * i + 1; // left = 2*i + 1\n  var r = 2 * i + 2; // right = 2*i + 2\n\n  // If left child is larger than root\n  if (l < n && arr[l] > arr[largest]) largest = l;\n\n  // If right child is larger than largest so far\n  if (r < n && arr[r] > arr[largest]) largest = r;\n\n  // If largest is not root\n  if (largest != i) {\n    var swap = arr[i];\n    arr[i] = arr[largest];\n    arr[largest] = swap;\n\n    // Recursively heapify the affected sub-tree\n    heapify(arr, n, largest);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}