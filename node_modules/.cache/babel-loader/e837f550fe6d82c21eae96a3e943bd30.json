{"ast":null,"code":"export function getHeapSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  doHeap(array, animations);\n  return animations;\n}\n\nfunction doHeap(array, animations) {\n  let n = array.length; // Build heap (rearrange array)\n\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(array, n, i, animations);\n  } // One by one extract elements from heap\n\n\n  for (let i = n - 1; i > 0; i--) {\n    // Move current root to end\n    let temp = array[0];\n    array[0] = array[i];\n    array[i] = temp;\n    animations.push([3, i, array[i], 0, array[0]]); // call max heapify on the reduced heap\n\n    heapify(array, i, 0, animations);\n  }\n} // To heapify a subtree rooted with node i which is\n// an index in array[]. n is size of heap\n\n\nfunction heapify(array, n, i, animations) {\n  let largest = i; // root\n\n  let l = 2 * i + 1; // left\n\n  let r = 2 * i + 2; // right\n\n  console.log(l); //animations.push([1, largest, l]);\n  //animations.push([2, largest, l]);\n\n  if (l < n && array[l] > array[largest]) {\n    largest = l;\n  }\n\n  if (r < n && array[r] > array[largest]) {\n    largest = r;\n  }\n\n  if (largest !== i) {\n    let temp = array[i];\n    array[i] = array[largest];\n    array[largest] = temp;\n    animations.push([3, largest, array[largest], i, array[i]]); // Recursively heapify the affected sub-tree\n\n    heapify(array, n, largest, animations);\n  }\n}","map":{"version":3,"sources":["/home/matta/algo_viz/src/Algos/HeapSort.js"],"names":["getHeapSortAnimations","array","animations","length","doHeap","n","i","Math","floor","heapify","temp","push","largest","l","r","console","log"],"mappings":"AAAA,OAAO,SAASA,qBAAT,CAA+BC,KAA/B,EAAsC;AAC3C,QAAMC,UAAU,GAAG,EAAnB;AACA,MAAID,KAAK,CAACE,MAAN,IAAgB,CAApB,EAAuB,OAAOF,KAAP;AACvBG,EAAAA,MAAM,CAACH,KAAD,EAAQC,UAAR,CAAN;AACA,SAAOA,UAAP;AACD;;AAED,SAASE,MAAT,CAAgBH,KAAhB,EAAuBC,UAAvB,EAAmC;AACjC,MAAIG,CAAC,GAAGJ,KAAK,CAACE,MAAd,CADiC,CAGjC;;AACA,OAAK,IAAIG,CAAC,GAAGC,IAAI,CAACC,KAAL,CAAWH,CAAC,GAAG,CAAf,IAAoB,CAAjC,EAAoCC,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD;AAC/CG,IAAAA,OAAO,CAACR,KAAD,EAAQI,CAAR,EAAWC,CAAX,EAAcJ,UAAd,CAAP;AACD,GANgC,CAQjC;;;AACA,OAAK,IAAII,CAAC,GAAGD,CAAC,GAAG,CAAjB,EAAoBC,CAAC,GAAG,CAAxB,EAA2BA,CAAC,EAA5B,EAAgC;AAC9B;AACA,QAAII,IAAI,GAAGT,KAAK,CAAC,CAAD,CAAhB;AACAA,IAAAA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAACK,CAAD,CAAhB;AACAL,IAAAA,KAAK,CAACK,CAAD,CAAL,GAAWI,IAAX;AACAR,IAAAA,UAAU,CAACS,IAAX,CAAgB,CAAC,CAAD,EAAIL,CAAJ,EAAOL,KAAK,CAACK,CAAD,CAAZ,EAAiB,CAAjB,EAAoBL,KAAK,CAAC,CAAD,CAAzB,CAAhB,EAL8B,CAO9B;;AACAQ,IAAAA,OAAO,CAACR,KAAD,EAAQK,CAAR,EAAW,CAAX,EAAcJ,UAAd,CAAP;AACD;AACF,C,CAED;AACA;;;AACA,SAASO,OAAT,CAAiBR,KAAjB,EAAwBI,CAAxB,EAA2BC,CAA3B,EAA8BJ,UAA9B,EAA0C;AACxC,MAAIU,OAAO,GAAGN,CAAd,CADwC,CACvB;;AACjB,MAAIO,CAAC,GAAG,IAAIP,CAAJ,GAAQ,CAAhB,CAFwC,CAErB;;AACnB,MAAIQ,CAAC,GAAG,IAAIR,CAAJ,GAAQ,CAAhB,CAHwC,CAGrB;;AACnBS,EAAAA,OAAO,CAACC,GAAR,CAAYH,CAAZ,EAJwC,CAKxC;AACA;;AAEA,MAAIA,CAAC,GAAGR,CAAJ,IAASJ,KAAK,CAACY,CAAD,CAAL,GAAWZ,KAAK,CAACW,OAAD,CAA7B,EAAwC;AACtCA,IAAAA,OAAO,GAAGC,CAAV;AACD;;AAED,MAAIC,CAAC,GAAGT,CAAJ,IAASJ,KAAK,CAACa,CAAD,CAAL,GAAWb,KAAK,CAACW,OAAD,CAA7B,EAAwC;AACtCA,IAAAA,OAAO,GAAGE,CAAV;AACD;;AAED,MAAIF,OAAO,KAAKN,CAAhB,EAAmB;AACjB,QAAII,IAAI,GAAGT,KAAK,CAACK,CAAD,CAAhB;AACAL,IAAAA,KAAK,CAACK,CAAD,CAAL,GAAWL,KAAK,CAACW,OAAD,CAAhB;AACAX,IAAAA,KAAK,CAACW,OAAD,CAAL,GAAiBF,IAAjB;AACAR,IAAAA,UAAU,CAACS,IAAX,CAAgB,CAAC,CAAD,EAAIC,OAAJ,EAAaX,KAAK,CAACW,OAAD,CAAlB,EAA6BN,CAA7B,EAAgCL,KAAK,CAACK,CAAD,CAArC,CAAhB,EAJiB,CAMjB;;AACAG,IAAAA,OAAO,CAACR,KAAD,EAAQI,CAAR,EAAWO,OAAX,EAAoBV,UAApB,CAAP;AACD;AACF","sourcesContent":["export function getHeapSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  doHeap(array, animations);\n  return animations;\n}\n\nfunction doHeap(array, animations) {\n  let n = array.length;\n\n  // Build heap (rearrange array)\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(array, n, i, animations);\n  }\n\n  // One by one extract elements from heap\n  for (let i = n - 1; i > 0; i--) {\n    // Move current root to end\n    let temp = array[0];\n    array[0] = array[i];\n    array[i] = temp;\n    animations.push([3, i, array[i], 0, array[0]]);\n\n    // call max heapify on the reduced heap\n    heapify(array, i, 0, animations);\n  }\n}\n\n// To heapify a subtree rooted with node i which is\n// an index in array[]. n is size of heap\nfunction heapify(array, n, i, animations) {\n  let largest = i; // root\n  let l = 2 * i + 1; // left\n  let r = 2 * i + 2; // right\n  console.log(l);\n  //animations.push([1, largest, l]);\n  //animations.push([2, largest, l]);\n\n  if (l < n && array[l] > array[largest]) {\n    largest = l;\n  }\n\n  if (r < n && array[r] > array[largest]) {\n    largest = r;\n  }\n\n  if (largest !== i) {\n    let temp = array[i];\n    array[i] = array[largest];\n    array[largest] = temp;\n    animations.push([3, largest, array[largest], i, array[i]]);\n\n    // Recursively heapify the affected sub-tree\n    heapify(array, n, largest, animations);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}