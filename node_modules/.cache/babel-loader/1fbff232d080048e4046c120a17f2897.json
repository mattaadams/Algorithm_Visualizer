{"ast":null,"code":"export function getQuickSortAnimations(array) {\n  const animations = []; // if (array.length <= 1) return array;\n\n  doQuick(arr, low, high, animations);\n  return animations;\n}\n\nfunction quickSortHelper(mainArray, startIdx, endIdx, auxiliaryArray, animations) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  quickSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n  quickSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n  doQuick(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction swap(arr, i, j) {\n  let temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}\n\nfunction partition(arr, low, high) {\n  // pivot\n  let pivot = arr[high]; // Index of smaller element and\n  // indicates the right position\n  // of pivot found so far\n\n  let i = low - 1;\n\n  for (let j = low; j <= high - 1; j++) {\n    // If current element is smaller\n    // than the pivot\n    if (arr[j] < pivot) {\n      // Increment index of\n      // smaller element\n      i++;\n      swap(arr, i, j);\n    }\n  }\n\n  swap(arr, i + 1, high);\n  return i + 1;\n}\n\nfunction doQuick(arr, low, high) {\n  if (low < high) {\n    // pi is partitioning index, arr[p]\n    // is now at right place\n    let pi = partition(arr, low, high); // Separately sort elements before\n    // partition and after partition\n\n    doQuick(arr, low, pi - 1);\n    doQuick(arr, pi + 1, high);\n  }\n}","map":{"version":3,"sources":["/home/matta/algo_viz/src/Algos/QuickSort.js"],"names":["getQuickSortAnimations","array","animations","doQuick","arr","low","high","quickSortHelper","mainArray","startIdx","endIdx","auxiliaryArray","middleIdx","Math","floor","swap","i","j","temp","partition","pivot","pi"],"mappings":"AAAA,OAAO,SAASA,sBAAT,CAAgCC,KAAhC,EAAuC;AAC5C,QAAMC,UAAU,GAAG,EAAnB,CAD4C,CAE5C;;AACAC,EAAAA,OAAO,CAACC,GAAD,EAAMC,GAAN,EAAWC,IAAX,EAAiBJ,UAAjB,CAAP;AAEA,SAAOA,UAAP;AACD;;AAED,SAASK,eAAT,CAAyBC,SAAzB,EAAoCC,QAApC,EAA8CC,MAA9C,EAAsDC,cAAtD,EAAsET,UAAtE,EAAkF;AAChF,MAAIO,QAAQ,KAAKC,MAAjB,EAAyB;AACzB,QAAME,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACL,QAAQ,GAAGC,MAAZ,IAAsB,CAAjC,CAAlB;AACAH,EAAAA,eAAe,CAACI,cAAD,EAAiBF,QAAjB,EAA2BG,SAA3B,EAAsCJ,SAAtC,EAAiDN,UAAjD,CAAf;AACAK,EAAAA,eAAe,CAACI,cAAD,EAAiBC,SAAS,GAAG,CAA7B,EAAgCF,MAAhC,EAAwCF,SAAxC,EAAmDN,UAAnD,CAAf;AACAC,EAAAA,OAAO,CAACK,SAAD,EAAYC,QAAZ,EAAsBG,SAAtB,EAAiCF,MAAjC,EAAyCC,cAAzC,EAAyDT,UAAzD,CAAP;AACD;;AAED,SAASa,IAAT,CAAcX,GAAd,EAAmBY,CAAnB,EAAsBC,CAAtB,EAAyB;AACvB,MAAIC,IAAI,GAAGd,GAAG,CAACY,CAAD,CAAd;AACAZ,EAAAA,GAAG,CAACY,CAAD,CAAH,GAASZ,GAAG,CAACa,CAAD,CAAZ;AACAb,EAAAA,GAAG,CAACa,CAAD,CAAH,GAASC,IAAT;AACD;;AAED,SAASC,SAAT,CAAmBf,GAAnB,EAAwBC,GAAxB,EAA6BC,IAA7B,EAAmC;AACjC;AACA,MAAIc,KAAK,GAAGhB,GAAG,CAACE,IAAD,CAAf,CAFiC,CAIjC;AACA;AACA;;AACA,MAAIU,CAAC,GAAGX,GAAG,GAAG,CAAd;;AAEA,OAAK,IAAIY,CAAC,GAAGZ,GAAb,EAAkBY,CAAC,IAAIX,IAAI,GAAG,CAA9B,EAAiCW,CAAC,EAAlC,EAAsC;AACpC;AACA;AACA,QAAIb,GAAG,CAACa,CAAD,CAAH,GAASG,KAAb,EAAoB;AAClB;AACA;AACAJ,MAAAA,CAAC;AACDD,MAAAA,IAAI,CAACX,GAAD,EAAMY,CAAN,EAASC,CAAT,CAAJ;AACD;AACF;;AACDF,EAAAA,IAAI,CAACX,GAAD,EAAMY,CAAC,GAAG,CAAV,EAAaV,IAAb,CAAJ;AACA,SAAOU,CAAC,GAAG,CAAX;AACD;;AAED,SAASb,OAAT,CAAiBC,GAAjB,EAAsBC,GAAtB,EAA2BC,IAA3B,EAAiC;AAC/B,MAAID,GAAG,GAAGC,IAAV,EAAgB;AACd;AACA;AACA,QAAIe,EAAE,GAAGF,SAAS,CAACf,GAAD,EAAMC,GAAN,EAAWC,IAAX,CAAlB,CAHc,CAKd;AACA;;AACAH,IAAAA,OAAO,CAACC,GAAD,EAAMC,GAAN,EAAWgB,EAAE,GAAG,CAAhB,CAAP;AACAlB,IAAAA,OAAO,CAACC,GAAD,EAAMiB,EAAE,GAAG,CAAX,EAAcf,IAAd,CAAP;AACD;AACF","sourcesContent":["export function getQuickSortAnimations(array) {\n  const animations = [];\n  // if (array.length <= 1) return array;\n  doQuick(arr, low, high, animations);\n\n  return animations;\n}\n\nfunction quickSortHelper(mainArray, startIdx, endIdx, auxiliaryArray, animations) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  quickSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n  quickSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n  doQuick(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction swap(arr, i, j) {\n  let temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}\n\nfunction partition(arr, low, high) {\n  // pivot\n  let pivot = arr[high];\n\n  // Index of smaller element and\n  // indicates the right position\n  // of pivot found so far\n  let i = low - 1;\n\n  for (let j = low; j <= high - 1; j++) {\n    // If current element is smaller\n    // than the pivot\n    if (arr[j] < pivot) {\n      // Increment index of\n      // smaller element\n      i++;\n      swap(arr, i, j);\n    }\n  }\n  swap(arr, i + 1, high);\n  return i + 1;\n}\n\nfunction doQuick(arr, low, high) {\n  if (low < high) {\n    // pi is partitioning index, arr[p]\n    // is now at right place\n    let pi = partition(arr, low, high);\n\n    // Separately sort elements before\n    // partition and after partition\n    doQuick(arr, low, pi - 1);\n    doQuick(arr, pi + 1, high);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}