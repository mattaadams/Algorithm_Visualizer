{"ast":null,"code":"export function getHeapSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  doHeap(array, animations);\n  return animations;\n}\n\nfunction doHeap(array, animations) {\n  var n = array.length; // Build heap (rearrayange arrayay)\n\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) heapify(array, n, i); // One by one extract an element from heap\n\n\n  for (let i = n - 1; i > 0; i--) {\n    // Move current root to end\n    let temp = array[0];\n    array[0] = array[i];\n    array[i] = temp; // call max heapify on the reduced heap\n\n    heapify(array, i, 0);\n  }\n} // To heapify a subtree rooted with node i which is\n// an index in array[]. n is size of heap\n\n\nfunction heapify(array, n, i) {\n  var largest = i; // Initialize largest as root\n\n  var l = 2 * i + 1; // left = 2*i + 1\n\n  var r = 2 * i + 2; // right = 2*i + 2\n  // If left child is larger than root\n\n  if (l < n && array[l] > array[largest]) largest = l; // If right child is larger than largest so far\n\n  if (r < n && array[r] > array[largest]) largest = r; // If largest is not root\n\n  if (largest !== i) {\n    let temp = array[i];\n    array[i] = array[largest];\n    array[largest] = temp;\n    animations.push([3, largest, array[largest], i, array[i]]); // Recursively heapify the affected sub-tree\n\n    heapify(array, n, largest);\n  }\n}","map":{"version":3,"sources":["/home/matta/algo_viz/src/Algos/HeapSort.js"],"names":["getHeapSortAnimations","array","animations","length","doHeap","n","i","Math","floor","heapify","temp","largest","l","r","push"],"mappings":"AAAA,OAAO,SAASA,qBAAT,CAA+BC,KAA/B,EAAsC;AAC3C,QAAMC,UAAU,GAAG,EAAnB;AACA,MAAID,KAAK,CAACE,MAAN,IAAgB,CAApB,EAAuB,OAAOF,KAAP;AACvBG,EAAAA,MAAM,CAACH,KAAD,EAAQC,UAAR,CAAN;AACA,SAAOA,UAAP;AACD;;AAED,SAASE,MAAT,CAAgBH,KAAhB,EAAuBC,UAAvB,EAAmC;AACjC,MAAIG,CAAC,GAAGJ,KAAK,CAACE,MAAd,CADiC,CAGjC;;AACA,OAAK,IAAIG,CAAC,GAAGC,IAAI,CAACC,KAAL,CAAWH,CAAC,GAAG,CAAf,IAAoB,CAAjC,EAAoCC,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiDG,OAAO,CAACR,KAAD,EAAQI,CAAR,EAAWC,CAAX,CAAP,CAJhB,CAMjC;;;AACA,OAAK,IAAIA,CAAC,GAAGD,CAAC,GAAG,CAAjB,EAAoBC,CAAC,GAAG,CAAxB,EAA2BA,CAAC,EAA5B,EAAgC;AAC9B;AACA,QAAII,IAAI,GAAGT,KAAK,CAAC,CAAD,CAAhB;AACAA,IAAAA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAACK,CAAD,CAAhB;AACAL,IAAAA,KAAK,CAACK,CAAD,CAAL,GAAWI,IAAX,CAJ8B,CAM9B;;AACAD,IAAAA,OAAO,CAACR,KAAD,EAAQK,CAAR,EAAW,CAAX,CAAP;AACD;AACF,C,CAED;AACA;;;AACA,SAASG,OAAT,CAAiBR,KAAjB,EAAwBI,CAAxB,EAA2BC,CAA3B,EAA8B;AAC5B,MAAIK,OAAO,GAAGL,CAAd,CAD4B,CACX;;AACjB,MAAIM,CAAC,GAAG,IAAIN,CAAJ,GAAQ,CAAhB,CAF4B,CAET;;AACnB,MAAIO,CAAC,GAAG,IAAIP,CAAJ,GAAQ,CAAhB,CAH4B,CAGT;AAEnB;;AACA,MAAIM,CAAC,GAAGP,CAAJ,IAASJ,KAAK,CAACW,CAAD,CAAL,GAAWX,KAAK,CAACU,OAAD,CAA7B,EAAwCA,OAAO,GAAGC,CAAV,CANZ,CAQ5B;;AACA,MAAIC,CAAC,GAAGR,CAAJ,IAASJ,KAAK,CAACY,CAAD,CAAL,GAAWZ,KAAK,CAACU,OAAD,CAA7B,EAAwCA,OAAO,GAAGE,CAAV,CATZ,CAW5B;;AACA,MAAIF,OAAO,KAAKL,CAAhB,EAAmB;AACjB,QAAII,IAAI,GAAGT,KAAK,CAACK,CAAD,CAAhB;AACAL,IAAAA,KAAK,CAACK,CAAD,CAAL,GAAWL,KAAK,CAACU,OAAD,CAAhB;AACAV,IAAAA,KAAK,CAACU,OAAD,CAAL,GAAiBD,IAAjB;AACAR,IAAAA,UAAU,CAACY,IAAX,CAAgB,CAAC,CAAD,EAAIH,OAAJ,EAAaV,KAAK,CAACU,OAAD,CAAlB,EAA6BL,CAA7B,EAAgCL,KAAK,CAACK,CAAD,CAArC,CAAhB,EAJiB,CAMjB;;AACAG,IAAAA,OAAO,CAACR,KAAD,EAAQI,CAAR,EAAWM,OAAX,CAAP;AACD;AACF","sourcesContent":["export function getHeapSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  doHeap(array, animations);\n  return animations;\n}\n\nfunction doHeap(array, animations) {\n  var n = array.length;\n\n  // Build heap (rearrayange arrayay)\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) heapify(array, n, i);\n\n  // One by one extract an element from heap\n  for (let i = n - 1; i > 0; i--) {\n    // Move current root to end\n    let temp = array[0];\n    array[0] = array[i];\n    array[i] = temp;\n\n    // call max heapify on the reduced heap\n    heapify(array, i, 0);\n  }\n}\n\n// To heapify a subtree rooted with node i which is\n// an index in array[]. n is size of heap\nfunction heapify(array, n, i) {\n  var largest = i; // Initialize largest as root\n  var l = 2 * i + 1; // left = 2*i + 1\n  var r = 2 * i + 2; // right = 2*i + 2\n\n  // If left child is larger than root\n  if (l < n && array[l] > array[largest]) largest = l;\n\n  // If right child is larger than largest so far\n  if (r < n && array[r] > array[largest]) largest = r;\n\n  // If largest is not root\n  if (largest !== i) {\n    let temp = array[i];\n    array[i] = array[largest];\n    array[largest] = temp;\n    animations.push([3, largest, array[largest], i, array[i]]);\n\n    // Recursively heapify the affected sub-tree\n    heapify(array, n, largest);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}