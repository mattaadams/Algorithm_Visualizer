{"ast":null,"code":"export function getHeapSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  doHeap(array, animations);\n  return animations;\n}\n\nfunction doHeap(array, animations) {\n  var n = array.length; // Build heap (rearrayange arrayay)\n\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) heapify(array, n, i); // One by one extract an element from heap\n\n\n  for (let i = n - 1; i > 0; i--) {\n    // Move current root to end\n    let temp = array[0];\n    array[0] = array[i];\n    array[i] = temp;\n    animations.push([3, i, array[i], 0, array[0]]); // call max heapify on the reduced heap\n\n    heapify(array, i, 0);\n  }\n} // To heapify a subtree rooted with node i which is\n// an index in array[]. n is size of heap\n\n\nfunction heapify(array, n, i, animations) {\n  var largest = i; // Initialize largest as root\n\n  var l = 2 * i + 1; // left = 2*i + 1\n\n  var r = 2 * i + 2; // right = 2*i + 2\n  // If left child is larger than root\n\n  if (l < n && array[l] > array[largest]) largest = l; // If right child is larger than largest so far\n\n  if (r < n && array[r] > array[largest]) largest = r; // If largest is not root\n\n  if (largest !== i) {\n    let temp = array[i];\n    array[i] = array[largest];\n    array[largest] = temp; //animations.push([3, largest, array[largest], i, array[i]]);\n    // Recursively heapify the affected sub-tree\n\n    heapify(array, n, largest);\n  }\n}","map":{"version":3,"sources":["/home/matta/algo_viz/src/Algos/HeapSort.js"],"names":["getHeapSortAnimations","array","animations","length","doHeap","n","i","Math","floor","heapify","temp","push","largest","l","r"],"mappings":"AAAA,OAAO,SAASA,qBAAT,CAA+BC,KAA/B,EAAsC;AAC3C,QAAMC,UAAU,GAAG,EAAnB;AACA,MAAID,KAAK,CAACE,MAAN,IAAgB,CAApB,EAAuB,OAAOF,KAAP;AACvBG,EAAAA,MAAM,CAACH,KAAD,EAAQC,UAAR,CAAN;AACA,SAAOA,UAAP;AACD;;AAED,SAASE,MAAT,CAAgBH,KAAhB,EAAuBC,UAAvB,EAAmC;AACjC,MAAIG,CAAC,GAAGJ,KAAK,CAACE,MAAd,CADiC,CAGjC;;AACA,OAAK,IAAIG,CAAC,GAAGC,IAAI,CAACC,KAAL,CAAWH,CAAC,GAAG,CAAf,IAAoB,CAAjC,EAAoCC,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiDG,OAAO,CAACR,KAAD,EAAQI,CAAR,EAAWC,CAAX,CAAP,CAJhB,CAMjC;;;AACA,OAAK,IAAIA,CAAC,GAAGD,CAAC,GAAG,CAAjB,EAAoBC,CAAC,GAAG,CAAxB,EAA2BA,CAAC,EAA5B,EAAgC;AAC9B;AACA,QAAII,IAAI,GAAGT,KAAK,CAAC,CAAD,CAAhB;AACAA,IAAAA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAACK,CAAD,CAAhB;AACAL,IAAAA,KAAK,CAACK,CAAD,CAAL,GAAWI,IAAX;AACAR,IAAAA,UAAU,CAACS,IAAX,CAAgB,CAAC,CAAD,EAAIL,CAAJ,EAAOL,KAAK,CAACK,CAAD,CAAZ,EAAiB,CAAjB,EAAoBL,KAAK,CAAC,CAAD,CAAzB,CAAhB,EAL8B,CAO9B;;AACAQ,IAAAA,OAAO,CAACR,KAAD,EAAQK,CAAR,EAAW,CAAX,CAAP;AACD;AACF,C,CAED;AACA;;;AACA,SAASG,OAAT,CAAiBR,KAAjB,EAAwBI,CAAxB,EAA2BC,CAA3B,EAA8BJ,UAA9B,EAA0C;AACxC,MAAIU,OAAO,GAAGN,CAAd,CADwC,CACvB;;AACjB,MAAIO,CAAC,GAAG,IAAIP,CAAJ,GAAQ,CAAhB,CAFwC,CAErB;;AACnB,MAAIQ,CAAC,GAAG,IAAIR,CAAJ,GAAQ,CAAhB,CAHwC,CAGrB;AAEnB;;AACA,MAAIO,CAAC,GAAGR,CAAJ,IAASJ,KAAK,CAACY,CAAD,CAAL,GAAWZ,KAAK,CAACW,OAAD,CAA7B,EAAwCA,OAAO,GAAGC,CAAV,CANA,CAQxC;;AACA,MAAIC,CAAC,GAAGT,CAAJ,IAASJ,KAAK,CAACa,CAAD,CAAL,GAAWb,KAAK,CAACW,OAAD,CAA7B,EAAwCA,OAAO,GAAGE,CAAV,CATA,CAWxC;;AACA,MAAIF,OAAO,KAAKN,CAAhB,EAAmB;AACjB,QAAII,IAAI,GAAGT,KAAK,CAACK,CAAD,CAAhB;AACAL,IAAAA,KAAK,CAACK,CAAD,CAAL,GAAWL,KAAK,CAACW,OAAD,CAAhB;AACAX,IAAAA,KAAK,CAACW,OAAD,CAAL,GAAiBF,IAAjB,CAHiB,CAIjB;AAEA;;AACAD,IAAAA,OAAO,CAACR,KAAD,EAAQI,CAAR,EAAWO,OAAX,CAAP;AACD;AACF","sourcesContent":["export function getHeapSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  doHeap(array, animations);\n  return animations;\n}\n\nfunction doHeap(array, animations) {\n  var n = array.length;\n\n  // Build heap (rearrayange arrayay)\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) heapify(array, n, i);\n\n  // One by one extract an element from heap\n  for (let i = n - 1; i > 0; i--) {\n    // Move current root to end\n    let temp = array[0];\n    array[0] = array[i];\n    array[i] = temp;\n    animations.push([3, i, array[i], 0, array[0]]);\n\n    // call max heapify on the reduced heap\n    heapify(array, i, 0);\n  }\n}\n\n// To heapify a subtree rooted with node i which is\n// an index in array[]. n is size of heap\nfunction heapify(array, n, i, animations) {\n  var largest = i; // Initialize largest as root\n  var l = 2 * i + 1; // left = 2*i + 1\n  var r = 2 * i + 2; // right = 2*i + 2\n\n  // If left child is larger than root\n  if (l < n && array[l] > array[largest]) largest = l;\n\n  // If right child is larger than largest so far\n  if (r < n && array[r] > array[largest]) largest = r;\n\n  // If largest is not root\n  if (largest !== i) {\n    let temp = array[i];\n    array[i] = array[largest];\n    array[largest] = temp;\n    //animations.push([3, largest, array[largest], i, array[i]]);\n\n    // Recursively heapify the affected sub-tree\n    heapify(array, n, largest);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}