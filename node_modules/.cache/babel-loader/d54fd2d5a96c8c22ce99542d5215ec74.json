{"ast":null,"code":"export function getHeapSortAnimations(array){var animations=[];if(array.length<=1)return array;doHeap(array,animations);return animations;}function doHeap(array,animations){var n=array.length;// Build heap (rearrange array)\nfor(var i=Math.floor(n/2)-1;i>=0;i--){heapify(array,n,i,animations);}// One by one extract elements from heap\nfor(var _i=n-1;_i>0;_i--){// Move current root to end\nvar temp=array[0];array[0]=array[_i];array[_i]=temp;animations.push([1,0,_i],[2,0,_i]);animations.push([3,_i,array[_i],0,array[0]]);// call max heapify on the reduced heap\nheapify(array,_i,0,animations);}}// To heapify a subtree rooted with node i which is\n// an index in array[]. n is size of heap\nfunction heapify(array,n,i,animations){var largest=i;// root\nvar l=2*i+1;// left\nvar r=2*i+2;// right\nif(l<n&&array[l]>array[largest]){largest=l;}if(r<n&&array[r]>array[largest]){largest=r;}if(largest!==i){var temp=array[i];array[i]=array[largest];array[largest]=temp;animations.push([7,l,r,i],[1,i,largest]);animations.push([3,largest,array[largest],i,array[i]]);animations.push([8,l,r,i]);// Recursively heapify the affected sub-tree\nheapify(array,n,largest,animations);}animations.push([2,largest,i]);}","map":{"version":3,"sources":["/home/matta/5_13_22/Algorithm_Visualizer/src/Algos/HeapSort.js"],"names":["getHeapSortAnimations","array","animations","length","doHeap","n","i","Math","floor","heapify","temp","push","largest","l","r"],"mappings":"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","sourcesContent":["export function getHeapSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  doHeap(array, animations);\n  return animations;\n}\n\nfunction doHeap(array, animations) {\n  let n = array.length;\n\n  // Build heap (rearrange array)\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(array, n, i, animations);\n  }\n\n  // One by one extract elements from heap\n  for (let i = n - 1; i > 0; i--) {\n    // Move current root to end\n    let temp = array[0];\n    array[0] = array[i];\n    array[i] = temp;\n    animations.push([1, 0, i], [2, 0, i]);\n    animations.push([3, i, array[i], 0, array[0]]);\n\n    // call max heapify on the reduced heap\n    heapify(array, i, 0, animations);\n  }\n}\n\n// To heapify a subtree rooted with node i which is\n// an index in array[]. n is size of heap\nfunction heapify(array, n, i, animations) {\n  let largest = i; // root\n  let l = 2 * i + 1; // left\n  let r = 2 * i + 2; // right\n\n  if (l < n && array[l] > array[largest]) {\n    largest = l;\n  }\n\n  if (r < n && array[r] > array[largest]) {\n    largest = r;\n  }\n\n  if (largest !== i) {\n    let temp = array[i];\n    array[i] = array[largest];\n    array[largest] = temp;\n    animations.push([7, l, r, i], [1, i, largest]);\n    animations.push([3, largest, array[largest], i, array[i]]);\n    animations.push([8, l, r, i]);\n\n    // Recursively heapify the affected sub-tree\n    heapify(array, n, largest, animations);\n  }\n  animations.push([2, largest, i]);\n}\n"]},"metadata":{},"sourceType":"module"}